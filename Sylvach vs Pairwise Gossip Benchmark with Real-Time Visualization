#!/usr/bin/env python3
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from dataclasses import dataclass
import secrets

# ---------------- CONFIG ----------------
@dataclass
class TrackerConfig:
    n_nodes: int = 1500
    dim: int = 4
    alpha: float = 0.12        
    gossip_scale: float = 0.4  
    noise_std: float = 8.0     
    n_steps: int = 300
    interval: int = 50
    master_seed: int = secrets.randbits(32) 

# ---------------- CONSENSUS LOGIC ----------------
def sylvach_step(states, alpha):
    # Global Mean: Every node updates based on the average
    mean = np.mean(states, axis=0)
    states += alpha * (mean - states)
    # Communication cost: N updates per step
    return states, len(states)

def gossip_step(states, scale):
    # Pairwise: Nodes only update in pairs
    n = len(states)
    idx = np.random.permutation(n)
    updates = 0
    for i in range(0, n - 1, 2):
        a, b = idx[i], idx[i+1]
        avg = (states[a] + states[b]) / 2
        states[a] += scale * (avg - states[a])
        states[b] += scale * (avg - states[b])
        updates += 2 
    return states, updates

# ---------------- VISUALIZER ----------------
class ComparisonTracker:
    def __init__(self, cfg: TrackerConfig):
        self.cfg = cfg
        np.random.seed(cfg.master_seed)
        initial_pool = np.random.randn(cfg.n_nodes, cfg.dim) * cfg.noise_std
        
        self.syl_states = initial_pool.copy()
        self.gos_states = initial_pool.copy()
        
        self.history = {
            'syl_err': [], 'gos_err': [], 
            'syl_comm': [0], 'gos_comm': [0]
        }

        plt.style.use('dark_background')
        self.fig = plt.figure(figsize=(16, 10))
        gs = self.fig.add_gridspec(2, 2, height_ratios=[2, 1])
        
        self.ax_syl = self.fig.add_subplot(gs[0, 0])
        self.ax_gos = self.fig.add_subplot(gs[0, 1])
        self.ax_met = self.fig.add_subplot(gs[1, :])

        # FIX: Added 'c=[]' to suppress the UserWarning
        self.scat_syl = self.ax_syl.scatter([], [], s=5, cmap='winter', c=[], alpha=0.5)
        self.scat_gos = self.ax_gos.scatter([], [], s=5, cmap='autumn', c=[], alpha=0.5)

        for ax, t in zip([self.ax_syl, self.ax_gos], ["Sylvach (Global Broadcast)", "Gossip (P2P Exchange)"]):
            ax.set_title(t, fontsize=14, color='white', weight='bold')
            ax.set_xlim(-15, 15); ax.set_ylim(-15, 15)
            ax.set_xlabel("Latent X"); ax.set_ylabel("Latent Y")

        self.line_syl, = self.ax_met.plot([], [], color='#00f2ff', label='Sylvach Residual', lw=2)
        self.line_gos, = self.ax_met.plot([], [], color='#ff0055', label='Gossip Residual', lw=2)
        
        self.ax_met.set_title(f"Seed: {cfg.master_seed} | Nodes: {cfg.n_nodes}", fontsize=10, loc='right', color='gray')
        self.ax_met.set_ylabel("Max System Error")
        self.ax_met.set_xlabel("Steps (Real-Time)")
        self.ax_met.legend(loc='upper right')
        
        # Text for real-time stats
        self.stats_text = self.ax_met.text(0.02, 0.05, '', transform=self.ax_met.transAxes, color='white', fontfamily='monospace')

    def update(self, frame):
        # Step Logic + Communication Tracking
        self.syl_states, s_comm = sylvach_step(self.syl_states, self.cfg.alpha)
        self.gos_states, g_comm = gossip_step(self.gos_states, self.cfg.gossip_scale)

        # Residual Calculation
        err_s = np.max(np.linalg.norm(self.syl_states - np.mean(self.syl_states, axis=0), axis=1))
        err_g = np.max(np.linalg.norm(self.gos_states - np.mean(self.gos_states, axis=0), axis=1))
        
        self.history['syl_err'].append(err_s)
        self.history['gos_err'].append(err_g)
        self.history['syl_comm'].append(self.history['syl_comm'][-1] + s_comm)
        self.history['gos_comm'].append(self.history['gos_comm'][-1] + g_comm)

        # Update Scatters
        self.scat_syl.set_offsets(self.syl_states[:, :2])
        self.scat_syl.set_array(np.linalg.norm(self.syl_states, axis=1))
        self.scat_gos.set_offsets(self.gos_states[:, :2])
        self.scat_gos.set_array(np.linalg.norm(self.gos_states, axis=1))

        # Update Lines
        xdata = range(len(self.history['syl_err']))
        self.line_syl.set_data(xdata, self.history['syl_err'])
        self.line_gos.set_data(xdata, self.history['gos_err'])
        
        # Adjust Y-axis for residual plot dynamically
        if frame == 0:
            self.ax_met.set_ylim(0, err_s * 1.2)
        self.ax_met.set_xlim(0, max(40, len(xdata)))

        # Update Stats Text
        self.stats_text.set_text(
            f"SYL Total Comm: {self.history['syl_comm'][-1]:,}\n"
            f"GOS Total Comm: {self.history['gos_comm'][-1]:,}\n"
            f"Error Ratio (G/S): {err_g/err_s:.2f}x"
        )

        # Visibility Zoom
        limit = max(err_s, err_g, 0.2) * 1.8
        self.ax_syl.set_xlim(-limit, limit); self.ax_syl.set_ylim(-limit, limit)
        self.ax_gos.set_xlim(-limit, limit); self.ax_gos.set_ylim(-limit, limit)

        return [self.scat_syl, self.scat_gos, self.line_syl, self.line_gos, self.stats_text]

    def run(self):
        ani = animation.FuncAnimation(self.fig, self.update, frames=self.cfg.n_steps, 
                                     interval=self.cfg.interval, blit=True)
        plt.tight_layout()
        plt.show()

if __name__ == "__main__":
    print("[*] Launching Convergence Tracker with Master Seed Symmetry...")
    ComparisonTracker(TrackerConfig()).run()
