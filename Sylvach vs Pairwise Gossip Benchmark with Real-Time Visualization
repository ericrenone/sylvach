#!/usr/bin/env python3
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from dataclasses import dataclass
import hashlib

# ---------------- IDENTITY & CRYPTO ----------------
def get_sha256(data_bytes):
    return hashlib.sha256(data_bytes).hexdigest()

def generate_sylvach_identity():
    """Generates the master seed from the SHA-256 hash of 'sylvach'."""
    hex_digest = get_sha256(b"sylvach")
    # Convert hex to integer for NumPy seeding
    seed = int(hex_digest[:16], 16) % (2**32)
    return hex_digest, seed

@dataclass
class TrackerConfig:
    n_nodes: int = 1500
    dim: int = 4
    alpha: float = 0.12        
    gossip_scale: float = 0.4  
    noise_std: float = 8.0     
    interval: int = 40         
    epsilon: float = 1e-8      # High-precision stop condition
    start_hash, master_seed = generate_sylvach_identity()

# ---------------- VECTORIZED LOGIC ----------------
def sylvach_step(states, alpha):
    mean = np.mean(states, axis=0)
    states += alpha * (mean - states)
    return states, len(states)

def gossip_step(states, scale):
    n = len(states)
    idx = np.random.permutation(n)
    if n % 2 != 0: idx = idx[:-1]
    a, b = idx[::2], idx[1::2]
    avg = (states[a] + states[b]) / 2
    states[a] += scale * (avg - states[a])
    states[b] += scale * (avg - states[b])
    return states, len(idx)

# ---------------- INFINITE VERIFICATION TRACKER ----------------
class PerpetualConsensusTracker:
    def __init__(self, cfg: TrackerConfig):
        self.cfg = cfg
        np.random.seed(cfg.master_seed)
        
        initial_pool = np.random.randn(cfg.n_nodes, cfg.dim) * cfg.noise_std
        self.syl_states = initial_pool.copy()
        self.gos_states = initial_pool.copy()
        
        self.history = {'syl_err': [], 'gos_err': [], 'syl_comm': [0], 'gos_comm': [0]}
        self.is_finished = False

        plt.style.use('dark_background')
        self.fig = plt.figure(figsize=(16, 11))
        gs = self.fig.add_gridspec(3, 2, height_ratios=[2, 1, 0.15])
        
        self.ax_syl = self.fig.add_subplot(gs[0, 0])
        self.ax_gos = self.fig.add_subplot(gs[0, 1])
        self.ax_met = self.fig.add_subplot(gs[1, :])
        self.ax_hash = self.fig.add_subplot(gs[2, :])
        self.ax_hash.axis('off')

        self.scat_syl = self.ax_syl.scatter([0], [0], c=[0], s=5, cmap='winter', alpha=0.5)
        self.scat_gos = self.ax_gos.scatter([0], [0], c=[0], s=5, cmap='autumn', alpha=0.5)

        for ax, t in zip([self.ax_syl, self.ax_gos], ["Sylvach Protocol", "Gossip Protocol"]):
            ax.set_title(t, fontsize=14, color='white', weight='bold')

        self.line_syl, = self.ax_met.plot([], [], color='#00f2ff', label='Sylvach Error', lw=2)
        self.line_gos, = self.ax_met.plot([], [], color='#ff0055', label='Gossip Error', lw=2)
        self.ax_met.set_ylabel("Linear Residual")
        self.ax_met.legend(loc='upper right', frameon=False)
        
        self.stats_text = self.ax_met.text(0.02, 0.05, '', transform=self.ax_met.transAxes, color='white', fontfamily='monospace')
        self.hash_display = self.ax_hash.text(0.5, 0.5, '', transform=self.ax_hash.transAxes, 
                                              ha='center', va='center', fontfamily='monospace', fontsize=9)

    def update(self, frame):
        if self.is_finished:
            return [self.scat_syl, self.scat_gos, self.line_syl, self.line_gos, self.stats_text]

        # Physics
        self.syl_states, s_c = sylvach_step(self.syl_states, self.cfg.alpha)
        self.gos_states, g_c = gossip_step(self.gos_states, self.cfg.gossip_scale)

        # Residuals
        err_s = np.max(np.linalg.norm(self.syl_states - np.mean(self.syl_states, axis=0), axis=1))
        err_g = np.max(np.linalg.norm(self.gos_states - np.mean(self.gos_states, axis=0), axis=1))
        delta = abs(err_g - err_s)

        self.history['syl_err'].append(err_s)
        self.history['gos_err'].append(err_g)
        self.history['syl_comm'].append(self.history['syl_comm'][-1] + s_c)
        self.history['gos_comm'].append(self.history['gos_comm'][-1] + g_c)

        # Cryptographic Verification
        current_state_bytes = self.syl_states.tobytes() + self.gos_states.tobytes()
        current_hash = get_sha256(current_state_bytes)

        # Visuals
        self.scat_syl.set_offsets(self.syl_states[:, :2])
        self.scat_syl.set_array(np.linalg.norm(self.syl_states, axis=1))
        self.scat_gos.set_offsets(self.gos_states[:, :2])
        self.scat_gos.set_array(np.linalg.norm(self.gos_states, axis=1))
        
        xdata = range(len(self.history['syl_err']))
        self.line_syl.set_data(xdata, self.history['syl_err'])
        self.line_gos.set_data(xdata, self.history['gos_err'])
        self.ax_met.set_xlim(0, max(60, len(xdata)))
        if frame == 0: self.ax_met.set_ylim(0, err_s * 1.1)

        # UI
        self.stats_text.set_text(f"DELTA: {delta:.10f} | STEP: {frame}\n"
                                 f"SYL COMM: {self.history['syl_comm'][-1]:,}\n"
                                 f"GOS COMM: {self.history['gos_comm'][-1]:,}")
        
        self.hash_display.set_text(f"START HASH: {self.cfg.start_hash}\n"
                                   f"CURRENT HASH: {current_hash}")
        
        # Camera
        s_m, g_m = np.mean(self.syl_states, axis=0), np.mean(self.gos_states, axis=0)
        limit = max(err_s, err_g, 0.4) * 1.6
        self.ax_syl.set_xlim(s_m[0]-limit, s_m[0]+limit); self.ax_syl.set_ylim(s_m[1]-limit, s_m[1]+limit)
        self.ax_gos.set_xlim(g_m[0]-limit, g_m[0]+limit); self.ax_gos.set_ylim(g_m[1]-limit, g_m[1]+limit)

        # INFINITE STOP TRIGGER
        if delta < self.cfg.epsilon and frame > 20:
            self.is_finished = True
            self.hash_display.set_color('#00ff00')
            print(f"[*] TOTAL CONVERGENCE AT STEP {frame}")
            print(f"[*] FINAL HASH: {current_hash}")
            self.ani.event_source.stop()

        return [self.scat_syl, self.scat_gos, self.line_syl, self.line_gos, self.stats_text, self.hash_display]

    def run(self):
        # frames=None makes the generator infinite
        self.ani = animation.FuncAnimation(self.fig, self.update, frames=None, 
                                          interval=self.cfg.interval, blit=True, cache_frame_data=False)
        plt.tight_layout(rect=[0, 0.03, 1, 0.95])
        plt.show()

if __name__ == "__main__":
    PerpetualConsensusTracker(TrackerConfig()).run()
